# Project Setup

## Version

The steps described in this document were tested using Ubuntu LTS >= 22. We strongly recommend the same setup is used when configuring and running the project.

## Pyenv

Install [Pyenv](https://github.com/pyenv/pyenv?tab=readme-ov-file#installation). If not already installed, get `curl` by running: `apt install curl`.  

To use the recommended automatic installer, run:  

`curl -fsSL https://pyenv.run | bash`

## pipx

The next step to set up the project is to install [pipx](https://pipx.pypa.io/stable/installation/).  

On Ubuntu>=23.04, the recommended way to get pipx is to run:

```
sudo apt update
sudo apt install pipx
pipx ensurepath
```

## Poetry

Now we need to install Poetry, which will be responsible for the virtual environment and the project dependencies. To do this, we need to run the following command in the terminal:

`pipx install poetry`

After installing Poetry, we need to run the following command in the terminal to ensure the virtual environment is created within the project root, and not in its default configuration:

`poetry config virtualenvs.in-project true`

## Just

After this, we need to install [just](https://github.com/casey/just). We've faced some issues when using the apt package, so we recommend [downloading the binary and adding it to your PATH](https://github.com/casey/just?tab=readme-ov-file#pre-built-binaries) instead.

Once Just is installed, clone the repository and from the project root, we need to run the following command in the terminal:

`just install`

Our Just commands can be found in the hidden `.just/` folder.

## PostgreSQL

This project uses [PostgreSQL](https://www.postgresql.org/) database. We need to install it by running the following command:

`apt install postgresql`

## Docker

We need to install [Docker Desktop](https://www.docker.com/), and after that run it.  

# Running the Project

## Create .env

For your **first running**, you must create a new `galp/.env` file with the `galp/.env.sample` content.

## Database

To first create the database image we need to run the following command from the project root:

`just compose db`

Then, for a local test environment, you simply run `just migrate` after composing the database container and starting it on your Docker Desktop. Note that running the migration from outside the container requires db authorization, as defined in your git ignored `galp/.env` file.

## Populate database for testing

Most of our models have a corresponding seed script to generate some test data. To run the seed script, use `just seed` from the root project folder.

## Run

To run the project, we need to run the following command in the terminal from the project root:

`just run`

## Quick API testing

With Uvicorn running, you should be able to access the API documentation generated by SwaggerUI at [http://localhost:8000/docs](http://localhost:8000/docs)

The documentation interface can be used to test our routes. Note that some of them may require you to be logged in, which can be done by posting `{"username": "admin", "password": "1234"}` to the Login route, and pasting the received token into the "Authorize" button at the top right of the webpage.

## Postman endpoint tests

You can run our Postman tests by importing the `/tests/Postman/galp.postman_collection.json` file into the Postman App, or using the CLI tool Newman:

`sudo npm install -g newman`
`newman run tests/Postman/galp.postman_collection.json`

# Publish the project

First, run the backend publish pipeline inside Azure DevOps. The pipeline will create a Docker image on the Docker Hub online repository and try to excecute the image inside the virtual machine on the Exacta infra.

After, we connect to the virtual machine via SSH to verify the HMG container is running: `ssh -i ~/hci.key -o StrictHostKeyChecking=no -o BatchMode=yes -p 8500 root@139.82.100.34`

To do the same for the DEV environment, the command is:  `ssh -i ~/hci.key -o StrictHostKeyChecking=no -o BatchMode=yes -p 8500 root@139.82.100.38`

Go to the Docker folder: `cd ..` -> `cd docker`

Verify the container is running with: `docker ps`

## Run migration

To run the migrations, we need to run a terminal inside the container with: `docker exec -t -i <YOUR_CONTAINER_ID> /bin/bash`

Once inside the Docker container (inside the virtual machine, connected via SSH), we run the following command to run migrations: `just migrate`

# Resources

There are two ways to save files in the project:

- Database
- As files

To configure it we need to set the value of the environment variable **RESOURCES_STORED_AS_FILES** in the **back-docker-compose.yaml** file (located in the `/docker` folder of the VMs). If the value of this variable is **true**, resources are saved as files; if it is **false**, resources are saved in the database.

Inside the VMs of each environment, we create the `/galp-backend/resources` folder and map the `galp-backend/resources` folder inside the container to point to this folder on the VM. This was done to ensure that files are not lost when a new container is deployed.

# Other Dependencies

## Node/Postman

We need Node.js v16 or higher to install Newman and run Postman tests on the CLI.

Alternatively, you can download the Postman App and import the test collection file.

# Docker Images

We need to create 2 Docker images in this project: one for the backend application and another for the database.

To create the backend application image we need to run the following command from the project root:

`just compose app`

To create the database image we need to run the following command from the project root:

`just compose db`

Note that, while running and testing locally, you might want to simply create the database image, followed by running the application with `just run`.

# Backup

The script responsible for backing up the application database and the resources folder on the VM is located in the `backup` folder of our project and its name is `galp_full_backup.sh`.
On the server, this file should be in the `/usr/local/bin` folder. We must remember to run the command `chmod +x galp_full_backup.sh` so that the file becomes an executable.
To manage the frequency at which the script will run, we are using **crontab**. To configure it, we need to use the command `crontab -e` (in HMG `sudo crontab -e`). Below is an example of an entry in **crontab** so that our script runs every day at 5 am:
```
# min   hour    day     month   weekday command
0       5       *       *       *       /usr/local/bin/galp_full_backup.sh
```
